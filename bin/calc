#!/usr/bin/perl -sT
use strict;
use warnings;

# Command line options...
our ($h, $b, $x);

# Help message...
if ($h) {
    print <<"EOF";
Simple calculator based on Perl's eval()

calc [options] <expression>

-h help
-b convert expression (or its result) to binary
-x convert expression (or its result) to hexadecimal

calc '(20+1)x2'
calc -b 255
calc -x 2**8
EOF
    exit 0;
}

# Allowed input characters regex...
my $allowed = qr'\d\+\-\/\*\.x';

# Transform input a bit...
@ARGV = ( "@ARGV" =~ /[$allowed]/g );   # un-taint
my $expr = "@ARGV";
$expr =~ s/\s+//g;                      # allow whitespace in input
$expr =~ s/x/*/gi;                      # allow x for multiplication
$expr =~ s/\^/**/g;                     # allow ^ for exponentiation

# Do the calculation...
my $res = eval "$expr";
die "Does not compute...$expr\n" unless defined $res;

if ($b) {
    # Show result in binary...
    printf "%s = %b\n", $expr, $res;
} elsif ($x) {
    # Show result in hex...
    printf "%s = %x\n", $expr, $res;
} else {
    # Show thousands in result but not in the decimal part...
    my ( $before_dot, $after_dot ) = split /\./, $res;
    $before_dot =~ s/(\d{1,3}?)(?=(\d{3})+$)/$1 /g;

    printf "%s = %s.%s\n", $expr, $before_dot, $after_dot // 0;
}

#!/usr/bin/perl -sT
use strict;
use warnings;

# Command line options...
our ($h, $b, $x, $c);

# Help message...
if ($h) {
    print <<'EOF';
Simple calculator based on Perl's eval()

calc [options] <expression>

-h  help
-b  convert expression (or its result) to binary
-x  convert expression (or its result) to hexadecimal
-c  convert expression (or its result) to character

calc 2**5 + 2x5    # x is the same as * (multiplication)
calc -b 2^8        # ^ is the same as ** (exponentiation)
calc -x 256
calc -c 2**17-3030
EOF
    exit 0;
}

# Allowed input characters regex...
my $allowed = qr'\d\+\-\/\*\.x';

# Transform input a bit...
@ARGV = ( "@ARGV" =~ /[$allowed]/g );   # un-taint
my $expr = "@ARGV";
$expr =~ s/\s+//g;                      # allow whitespace in input
$expr =~ s/x/*/gi;                      # allow x for multiplication
$expr =~ s/\^/**/g;                     # allow ^ for exponentiation

# Do the calculation...
my $res = eval "$expr";
die "Does not compute...$expr\n" unless defined $res;

if ($b) {
    # Show result in binary...
    printf "%s = %b\n", $expr, $res;
} elsif ($x) {
    # Show result in hex...
    printf "%s = %x\n", $expr, $res;
} elsif ($c) {
    # Show result as character...
    binmode(STDOUT, ':utf8');
    printf "%s = %c\n", $expr, $res;
} else {
    # Show thousands in result but not in the decimal part...
    my ( $before_dot, $after_dot ) = split /\./, $res;
    $before_dot =~ s/(\d{1,3}?)(?=(\d{3})+$)/$1 /g;

    printf "%s = %s.%s\n", $expr, $before_dot, $after_dot // 0;
}

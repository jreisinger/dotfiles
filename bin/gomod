#!/bin/bash
set -e # exit on error

REPO_PREFIX=github.com/jreisinger

MOD="$1"
PKG="pkg"

# Help.
if [ -z $MOD ]; then
    cat << EOF
$0 creates typical Go code directories and files. Based on
https://golang.org/doc/code.html. Usage:

$0 <module>
cd <module>
make run
docker build . -t <module>
EOF
    exit 1
fi

# Create repository. Repository typically contains only one module.
REPO="$MOD"
mkdir $REPO
cd $REPO
go mod init $REPO_PREFIX/$MOD

mkdir $PKG

# Create package source file.
cat << EOF > $PKG/src-file1.go
package $PKG

import (
	"fmt"
)

func Func(name string) string {
	return fmt.Sprintf("Hello from Func of $PKG, %s", name)
}
EOF

# Create package source test file.
cat << EOF > $PKG/src-file1_test.go
package $PKG

import (
	"testing"
)

func TestFunc(t *testing.T) {
	cases := []struct {
		in, want string
	}{
		{"Dude", "Hello from Func of $PKG, Dude"},
		{"", "Hello from Func of $PKG, "},
	}
	for _, c := range cases {
		got := Func(c.in)
		if got != c.want {
			t.Errorf("Func(%q) == %q, want %q", c.in, got, c.want)
		}
	}
}
EOF

# Create the main executable command.
cat << EOF > main.go
package main

import (
	"fmt"

    "$REPO_PREFIX/$MOD/$PKG"
)

func main() {
   out := $PKG.Func("Dude")
   fmt.Println(out)
}
EOF

# Create Makefile.
cat << 'EOF' > Makefile
test:
	if [ ! -z "${SOME_VAR}" ]; then\
		go clean -testcache ./...;\
		go test ./... -tags manual;\
	else\
		go test ./...;\
	fi

build: test
	CGO_ENABLED=0 go build
EOF
cat << EOF >> Makefile

run: build
	./$MOD
EOF

# Create Dockerfile.
cat << EOF > Dockerfile
FROM golang AS build

# Set the current working directory inside container.
WORKDIR /app

# Download all dependencies.
COPY go.* ./
RUN go mod download

# Build the app.
COPY . ./
RUN make build

# Create a single layer image.
FROM alpine:latest
COPY --from=build /app/$MOD /bin/$MOD

ENTRYPOINT ["/bin/$MOD"]
EOF
